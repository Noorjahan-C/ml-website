[
  {
    "objectID": "svm.html",
    "href": "svm.html",
    "title": "Support Vector Machine (SVM)",
    "section": "",
    "text": "1 Support Vector Machine (SVM)\nThis page will include:\n\nMargin & support vectors\nLinear vs kernel SVM\nExample with scikit-learn"
  },
  {
    "objectID": "numpy_intro.html",
    "href": "numpy_intro.html",
    "title": "NumPy Notes",
    "section": "",
    "text": "What is NumPy?\nNumPy (Numerical Python) is a powerful Python library used for numerical computations. It provides support for large, multi -dimensional arrays and matrices, along with a collection of mathematical functions to operate on these arrays efficiently. NumPy is widely used in scientific computing, data analysis, machine learning, and AI applications.\nNumPy is an essential library for numerical computations in Python. Its efficiency, speed, and ease of use make it indispensable for data scien ce, AI, and scientific computing. Whether you’re working with large datasets, complex mathematical functions, or machine learning models, NumPy is the go -to tool.\nWhy Do We Need NumPy?\n1. Efficient Computation\n NumPy is significantly faster than Python lis ts because it uses C and Fortran under the hood.\n It provides optimized vectorized operations that eliminate the need for loops in numerical computations.\n2. Memory Efficiency\n NumPy arrays consume less memory compared to Python lists due to their fixed data\ntype and efficient storage.\n3. Multi -Dimensional Arrays (ndarray)\n NumPy supports n -dimensional arrays, making it useful for handling matrices and tensor operations.\n4. Broadcasting\n It allows arithmetic operations on arrays of different shapes without expl icitly reshaping them.\n5. Built -in Mathematical Functions\n Includes a vast range of mathematical functions like sin() , cos() , log() , mean() , std() , etc.\n6. Integration with Other Libraries\n NumPy is the foundation of many data science and AI libraries, such as Pandas, SciPy, TensorFlow, and PyTorch.\nHow to Use NumPy?\n1. Installation\npip install numpy\n2. Importing NumPy\nimport numpy as np\n3. Creating Arrays\n# Creating a 1D array\narr1 = np.array([1, 2, 3, 4, 5])\nprint(arr1)\n\n1 Creating a 2D array\narr2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2)\n4. Array Properties\nprint(arr2.shape) # (2, 3) -&gt; Rows, Columns\nprint(arr2.size) # Total number of elements\nprint(arr2.dtype) # Data type of elements\n5. Special Arrays\nnp.zeros((3, 3)) # 3x3 matrix filled with zeros np.ones((2, 2)) # 2x2 matrix filled with ones\nnp.eye(3) # Identity matrix of size 3x3\nnp.arange(0, 10, 2) # Array from 0 to 10 with step 2\nnp.linspace(1, 5, 10) # 10 values between 1 and 5\n6. Mathematical Operations\na = np.array([1, 2, 3]) b = np.array([4, 5, 6])\nprint(a + b) # Element -wise addition\nprint(a - b) # Element -wise subtraction\nprint(a * b) # Element -wise multiplication\nprint(a / b) # Element -wise division\nprint(np.dot(a, b)) # Dot product\n7. Array Reshaping\narr = np.arange(1, 10)\nreshaped = arr.reshape(3, 3) # Reshapes 1D array into 3x3 matrix\nprint(reshaped)\n8. Indexing & Slicing\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[1]) # 20 (Indexing)\nprint(arr[1:4]) # [20, 30, 40] (Slicing)\n9. Aggregation Function s arr = np.array([10, 20, 30, 40])\nprint(np.sum(arr)) # Sum of elements\nprint(np.mean(arr)) # Mean of elements\nprint(np.std(arr)) # Standard deviation\nprint(np.min(arr)) # Minimum value\nprint(np.max(arr)) # Maximum value\n10. Random Numbers\nnp.random.rand(3, 3) # 3x3 matrix of random numbers between 0 and 1\nnp.random.randint(1, 100, (3, 3)) # 3x3 matrix of random integers from 1 to 100\nWhy Do We Need NumPy Arrays Instead of Python Lists or Standard Python Sequences?\nPython lists are flexible and easy to use, but they have significant performance and memory limitations when dealing with large numerical computations. NumPy arrays ( ndarray ) are optimized for performance, memory efficiency, and numerical operations, making them a superior choice for numerical and scientific computing.\n\nPerformance: NumPy is Faster than Python Lists\nReason: NumPy Uses Optimized C Implementations\nNumPy operations are implemented in C and Fortran , which makes them significantly faster\nthan Python lists, wh ich are dynamically typed and interpreted at runtime.\nExample: Speed Comparison\nLet’s compare the speed of NumPy arrays and Python lists for an element -wise multiplication operation.\nLet’s compare the speed of NumPy arrays and Python lists for an element -wise multiplication operation.\n\nimport numpy as np\nimport time\n\n\n2 Creating large lists and arrays\nsize = 10**6\npy_list1 = list(range(size))\npy_list2 = list(range(size))\nnp_array1 = np.arange(size)\nnp_array2 = np.arange(size)\n\n\n3 Timing Python list multiplica tion\nstart = time.time()\npy_result = [x * y for x, y in zip(py_list1, py_list2)]\nend = time.time()\nprint(“Python List Time:”, end - start)\n\n\n4 Timing NumPy array multiplication\nstart = time.time()\nnp_result = np_array1 * np_array2 # Vectorized operation\nend = time.time()\nprint(“NumPy Array Time:”, end – start) Result: NumPy is typically 10-100x faster than Python lists for large operations.\n\nMemory Efficiency: NumPy Uses Less Memory\nReason: NumPy Stores Data More Compactly\nPython lists store elements as objects , which introduce extra overhead. NumPy arrays store elements as contiguous blocks of memory with fixed data types , making them more space - efficient.\nExample: Memory Usage Comparison\n\nimport sys\nsize = 1000\n\n\n5 Python list memory consumption\npy_l ist = list(range(size))\nprint(“Python List Memory (bytes):”, sys.getsizeof(py_list) + sum(sys.getsizeof(i) for i in py_list))\n\n\n6 NumPy array memory consumption\nnp_array = np.arange(size)\nprint(“NumPy Array Memory (bytes):”, np_array.nbytes)\nResult: NumPy a rrays consume significantly less memory than Python lists.\n\nBroadcasting: Element -wise Operations Without Loops\nReason: NumPy Supports Vectorized Operations\nIn Python lists, operations require explicit loops or list comprehensions, while NumPy arrays perform operations in a vectorized manner (applied to all elements simultaneously).\nExample: Python List vs. NumPy Array Operations\n\n\n\n7 Using Python lists (Requires a loop)\npy_list = [1, 2, 3, 4, 5]\npy_result = [x * 2 for x in py_list] # Requires explicit iteration\n\n\n8 Using NumPy (No loop required)\nnp_array = np.array([1, 2, 3, 4, 5])\nnp_result = np_array * 2 # Vectorized operation\nResult: NumPy code is cleaner, shorter, and faster .\n\nMulti -Dimensional Data Handlin g Reason: NumPy Supports Multi -Dimensional Arrays (ndarray)\nPython lists require nested lists to represent matrices, making indexing and operations cumbersome. NumPy provides n-dimensional array s (ndarray) , allowing for efficient matrix operations . Example: 2D Matrix Operations\n\n\n\n9 Python list (Nested list representation)\npy_matrix = [[1, 2, 3], [4, 5, 6]]\npy_matrix_transpose = [[py_matrix[j][i] for j in range(2)] for i in range(3)] # Manual tran spose\n\n\n10 NumPy (Direct operations)\nnp_matrix = np.array([[1, 2, 3], [4, 5, 6]])\nnp_transpose = np_matrix.T # Transpose\nResult: NumPy allows built -in, optimized matrix operations , avoiding manual loops.\n\nBuilt -in Mathematical Functions\nReason: NumPy Provides Extensive Mathematical Functions\nPython lists require manual implementations or math /statistics modules, while NumPy offers efficient built -in functions . Example: Computing Mean and Standard Deviation\nimport statistics\n\npy_list = [1, 2, 3, 4, 5]\n\n\n11 Using Python’s statistics module\npy_mean = statistics.mean(py_list)\npy_std = statistics.stdev(py_list)\n\n\n12 Using NumPy (Optimized)\nnp_array = np.array([1, 2, 3, 4, 5])\nnp_mean = np_array.mean()\nnp_std = np_array.std()\nprint(“Python Mean:”, py_mean, ” Num Py Mean:“, np_mean)\nprint(”Python Std Dev:“, py_std,” NumPy Std Dev:“, np_std)\nResult: NumPy is more efficient for large datasets.\n\nAdvanced Operations: Linear Algebra & Random Number Generation\nNumPy provides:\n Linear Algebra (e.g., matrix multiplicat ion, eigenvalues, determinants)\n Random Number Generation (e.g., normal distribution, uniform distribution)\n Fourier Transforms & Signal Processing\nExample: Matrix Multiplication\n\nA = np.array([[1, 2], [3, 4]])\nB = np.array([[5, 6], [7, 8]])\n\n\n13 Matrix multiplication\nC = np.dot(A, B)\nprint(C)\nVectorization in NumPy\nVectorization is a technique in NumPy that allows operations to be applied to entire arrays (vectors) at once, without the need for explicit loops . This is possible because NumPy executes o perations in compiled C code under the hood, making them significantly faster and more efficient than using Python loops.\nWhy Use Vectorization?\n1. Faster Execution:\n NumPy operations run in optimized C code, avoiding Python’s slow loops.\n2. Simpler Code:\n No need for “ for” loops or list comprehensions.\n3. Memory Efficient:\n NumPy arrays use contiguous memory blocks, reducing overhead.\n4. Parallel Execution:\n Takes advantage of SIMD (Single Instruction Multiple Data) processing.\nExample: Without vs. With Vectorization\nUsing Python Loops (Slow)\nimport numpy as np\nimport time\n\n\n14 Creating large arrays\nsize = 10**6\npy_list1 = list(range(size))\npy_list2 = list(range(size))\nstart = time.time()\nresult = [x * y for x, y in zip(py_list1, py_list2)] # Loop -based multiplication\nend = time.time()\nprint(“Python Loop Time:”, end – start)\nUsing NumPy Vectorization (Fast)\n# Using NumPy (Vectorized)\nnp_array1 = np.arange(size)\nnp_array2 = np.arange(size)\nstart = time.time()\nresult = np_array1 * np_array2 # Vectorized multiplication\nend = time.time()\nprint(“NumPy Vectorization Time:”, end – start)\nResult: NumPy’s vectorized operations can be 10-100x faster than using Python loops!\nBroadcasting in NumPy\nWhat is Broadcasting?\nBroadcasting is a feature in NumPy that allows operations between arrays of different shapes without the need for explicit loops or reshaping. Instead of manually adjusting array dimensions, NumPy automatically expands smaller arrays so that element -wise operations can be performed efficie ntly.\nWhy is Broadcasting Useful?\nAvoids Explicit Loops → Faster execution\nMemory Efficient → No unnecessary copies of arrays\nSimplifies Code → Cleaner and more readable\nBroadcasting Rules\nFor NumPy to perform broadcasting, it follows three simple rules to match array shapes:\n If the dimensions are different, NumPy automatically adds missing dimensions to the smaller array (left -padding with 1s).\n If one dimension is 1, NumPy stretches it to match the other dimension.\n If dimensions are incompatible (n either is 1 and they are different), an error occurs.\nExamples of Broadcasting\nScalar and Array Broadcasting\nimport numpy as np\narr = np.array([1, 2, 3]) # Shape: (3,)\nscalar = 10 # Shape: ()\nresult = arr + scalar # Broadcasting applies here\nprint(re sult) # [11 12 13]\nNumPy automatically expands scalar to match arr. Shape transformation: (3,) + () → (3,)\nNumPy Arrays\nNumPy arrays ( ndarray ) are multi -dimensional, fast, and memory -efficient structures used for numerical operations. Let’s explore their creation, access, assignment, slicing, and attributes .\n\nCreating NumPy Arrays\n\nimport numpy as np\n\n\n15 1D Array\narr1 = np.array([1, 2, 3, 4, 5])\nprint(arr1)\n\n\n16 2D Array (Matrix)\narr2 = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr2)\n\n\n17 3D Array\narr3 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(arr3)\nNumPy arrays are more efficient than Python lists for numerical computations.\n\nAccessing Elements in NumPy Arrays\n1D Array Indexin g arr = np.array([10, 20, 30, 40, 50])\n\nprint(arr[0]) # First element → 10\nprint(arr[ -1]) # Last element → 50\n2D Array Indexing\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr[0, 0]) # First row, first column → 1\nprint(arr[1, 2]) # Second row, third column → 6\n3D Array Indexing\narr = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]])\nprint(arr[0, 1, 1]) # First block, second row, second column → 4\nNumPy allows direct indexing without nested loops!\n\nAssigning Values to NumPy Arrays\n\narr = np.array([10, 20, 30]) arr[1] = 99 # Modifies second element\nprint(arr) # [10 99 30]\nNumPy arrays are mutable , meaning values can be changed.\n\nSlicing NumPy Arrays\n1D Array Slicing\narr = np.array([10, 20, 30, 40, 50])\n\nprint(arr[1:4]) # [20 30 40] (Elements from index 1 to 3)\nprint(arr[:3]) # [10 20 30] (First three elements)\nprint(arr[::2]) # [10 30 50] (Every second element)\n2D Array Slicing\narr = np.array([[1, 2, 3], [4, 5, 6], [7, 8, 9]])\nprint(arr[:2, 1:]) # Extracts first two rows, from second column o nward Slicing does not create a new copy but a view! (Changes in slices affect the original array.)\n\nArray Attributes\nNumPy arrays have various attributes that describe their properties.\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\nprint(arr.ndim) # Number of dimensions (2D → 2)\nprint(arr.shape) # Shape (Rows, Columns) → (2, 3)\nprint(arr.size) # Total number of elements → 6\nprint(arr.dtype) # Data type of elements → int\nprint(arr.itemsize) # Memory size of each element (bytes)\nAttributes help und erstand the structure and storage details of the array.\n\nArray Dimension ( ndim )\n\narr1 = np.array([1, 2, 3]) # 1D Array → ndim = 1\narr2 = np.array([[1, 2, 3], [4, 5, 6]]) # 2D Array → ndim = 2\narr3 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) # 3D Array → ndim = 3\nprint(arr1.ndim) # 1 print(arr2.ndim) # 2 print(arr3.ndim) # 3 Higher dimensions are useful for machine learning, image processing, and tensor operations.\n\nArray Shape ( shape )\n\narr1 = np.array([1, 2, 3]) # Shape → (3,)\narr2 = np.array([[1, 2, 3], [4, 5, 6]]) # Shape → (2,3)\narr3 = np.array([[[1, 2], [3, 4]], [[5, 6], [7, 8]]]) # Shape → (2,2,2)\nprint(arr1.shape) # (3,) print(arr2.shape) # (2,3) print(arr3.shape) # (2,2,2) Shape represents (rows, columns, depth, etc .) and helps in reshaping and broadcasting.\n\nArray Size ( size )\n\narr1 = np.array([1, 2, 3]) # Size → 3 arr2 = np.array([[1, 2, 3], [4, 5, 6]]) # Size → 6\nprint(arr1.size) # 3 print(arr2.size) # 6 Size tells the total number of elements present in th e array.\n\nChanging the Shape of an Array\nUsing reshape() - Reshape is useful when working with machine learning models that require specific input dimensions.\n\narr = np.arange(1, 10) # [1 2 3 4 5 6 7 8 9]\nreshaped_arr = arr.reshape(3, 3) # Converts 1D to 3x3 matrix\nprint(reshaped_arr)\n\nCreating Special Arrays\nCreating a Zeros Array - Creates an array filled with zeros of a given shape.\n\nimport numpy as np\nzeros_arr = np.zeros((3, 4)) # 3x4 matrix of zeros\nprint(zeros_arr)\n\nCreating an Ones Array - Creates an array filled with ones.\n\nones_arr = np.ones((2, 3)) # 2x3 matrix of ones\nprint(ones_arr)\n\nCreating an Empty Array - Creates an array with uninitialized values (useful for efficiency).\n\nempty_arr = np.empty((2, 2)) # Creates an unin itialized array (values are random)\nprint(empty_arr)\n13. Creating Ranges & Linearly Spaced Arrays\nUsing np.arange() for Range Creation - Creates a sequence from start to end (exclusive) with step .\narr = np.arange(1, 10, 2) # [1 3 5 7 9]\nprint(arr)\nUsing np.linspace() for Linearly Spaced Values - Creates num evenly spaced values between start and end .\narr = np.linspace(0, 10, 5) # [0. 2.5 5. 7.5 10.]\nprint(arr)\n\nSorting Arrays - Sorts an array in ascending order.\n\narr = np.array([3, 1, 4, 2, 5] ) sorted_arr = np.sort(arr) # [1 2 3 4 5]\nprint(sorted_arr)\n\nConcatenating Arrays\nConcatenating Along Rows (Axis=0) - Joins two arrays along rows.\n\narr1 = np.array([[1, 2], [3, 4]])\narr2 = np.array([[5, 6]])\nconcat_arr = np.concatenate((arr1, arr2), axis=0) print(concat_arr)\nConcatenating Along Columns (Axis=1) - Joins two arrays along columns.\narr1 = np.array([[1, 2], [3, 4]])\narr2 = np.array([[5], [6]])\nconcat_arr = np.concatenate((arr1, arr2), axis=1)\nprint(concat_arr)\n\nReshaping Arrays - Reshapes a 1D array into a 2D array.\n\narr = np.arange(6)\nreshaped_arr = arr.reshape(2, 3)\nprint(reshaped_arr)\n\nAdding a New Dimension\nUsing np.newaxis - Adds an extra dimension (e.g., converting 1D to 2D).\n\narr = np.array([1, 2, 3])\narr_2d = arr[:, np.newaxis]\nprint(arr_2d.shape) # (3, 1)\nUsing np.expand_dims() - Expands the array along a specified axis.\narr = np.array([1, 2, 3])\nexpanded_arr = np.expand_dims(arr, axis=0)\nprint(expanded_arr.shape) # (1, 3)\n\nSlicing Arrays - Extracts part of t he array.\n\narr = np.array([10, 20, 30, 40, 50])\nprint(arr[1:4]) # [20 30 40] (Extract elements 1 to 3)\n\nCondition -Based Slicing - Selects elements that meet a condition.\n\narr = np.array([10, 20, 30, 40, 50])\nfiltered_arr = arr[arr &gt; 25] # [30 40 50]\nprint(filtered_arr)\n\nStacking Arrays\nVertical Stacking ( vstack ) - Stacks arrays row -wise (vertically).\n\narr1 = np.array([1, 2])\narr2 = np.array([3, 4])\nvstacked = np.vstack((arr1, arr2))\nprint(vstacked)\nHorizontal Stacking ( hstack ) - Stacks arrays column -wise (horizontally).\narr1 = np.array([[1], [2]])\narr2 = np.array([[3], [4]])\nhstacked = np.hstack((arr1, arr2))\nprint(hstacked)\n\nSplitting Arrays\nHorizontal Splitting - Splits an array into multiple sub -arrays along columns.\n\narr = np.array([[1, 2, 3, 4], [5, 6, 7, 8]])\nsplit_arr = np.hsplit(arr, 2)\nprint(split_arr)\n\nViews vs Copies in NumPy\nView (Shallow Copy) - Changes in a view affect the original array.\n\narr = np.array([1, 2, 3, 4])\nview_arr = arr.view()\nview_arr[0] = 99 # Modifies original\nprint(arr) # [99 2 3 4]\nCopy (Deep Copy) - A copy creates a separate array.\narr = np.array([1, 2, 3, 4])\ncopy_arr = arr.copy()\ncopy_arr[0] = 99 # Does NOT modify original\nprint(arr) # [1 2 3 4]\n\nBasic Arithmetic Operations in NumPy\nNumPy allows element -wise arithmetic operations on arrays without loops.\nAddition of Arrays\n\nimport numpy as np\narr1 = np.array([1, 2, 3])\narr2 = np.array([4, 5, 6])\nresult = arr1 + arr2 # Element -wise addition\nprint(result) # [5 7 9] Subtraction of Arrays\nresult = arr1 - arr2 # Element -wise subtraction\nprint(result) # [-3 -3 -3] Multiplication of Arrays\nresult = arr1 * arr2 # Element -wise multiplication\nprint(result) # [4 10 18]\nDivision of Arrays\nresult = arr1 / arr2 # Element -wise division\nprint(result) # [0.25 0.4 0.5]\nNumPy automatically handles division by zero, returning inf instead of an error.\n\nAggregate Functions\nNumPy provides fast aggregate functions for numerical computations.\nSum of Elements\n\narr = np.array([1, 2, 3, 4, 5])\nprint(np.sum(arr)) # 15 Minimum & Maximum Value\nprint(np.min(arr)) # 1 print(np.max(arr)) # 5 Product of All Elements\nprint(np.prod(arr)) # 120 (12345)\nMean (Average)\nprint(np.mean(arr)) # 3.0\nStandard Deviation ( std) print(np.std(arr)) # 1.4142135623730951\nStandard deviation measures data dispersion.\n\nRandom Number Generation\nNumPy has a built -in random module ( np.random ). Generate Random Numbers (0 to 1)\nrand_arr = np.random.rand(3, 3) # 3x3 matrix of random numbers between 0 and 1\nprint(rand_arr)\nGenerate Random Integers\nrand_int = np.random.randint(1, 100, (3, 3)) # 3x3 matrix with random integers from 1 to 100\nprint(rand_int)\nGenerate Normally Distributed Random Numbers\nrand_norm = np.random.randn(5) # 5 random numbers from nor mal distribution (mean=0, std=1)\nprint(rand_norm)\nUseful for statistics & machine learning.\nTransposing a Matrix\n\narr = np.array([[1, 2, 3], [4, 5, 6]])\ntransposed = np.transpose(arr)\nprint(transposed)\nFlips the matrix along the diagonal (rows → columns, columns → rows).\n\nReversing & Flipping Arrays\nReverse a 1D Array\narr = np.array([1, 2, 3, 4, 5])\nreversed_arr = arr[:: -1] print(reversed_arr) # [5 4 3 2 1]\nReverse Rows in a 2D Array\narr = np.array([[1, 2, 3], [4, 5, 6]])\nreversed_rows = arr[:: -1, :] print(reversed_rows)\n\nReverse Columns in a 2D Array\nreversed_cols = arr[:, :: -1] print(reversed_cols)\nFlipping rows or columns is useful for image processing and data transformations.\n28. Flattening Multidimensional Arrays\nUsing flatten() - Creates a new 1D array (copy of original).\narr = np.array([[1, 2], [3, 4]])\nflat_arr = arr.flatten()\nprint(flat_arr) # [1 2 3 4] Using ravel() - Returns a flattened view (does not create a copy).\nflat_arr_ravel = arr.ravel()\nprint(flat_arr_ravel) # [1 2 3 4]\nImportant Things to Keep in Mind While Using NumPy & Common Pitfalls\nWhile NumPy is powerful and efficient, there are several things you must keep in mind to avoid performance issues, incorrect results, or unexpected behaviour. Here’s a list of best practices and common pitfalls to watch out for.\n\nAvoid Using Python Loops - Use Vectorization\nThe Problem: Using Loops for Operations\nUsing for loops instead of NumPy’s vectorized operations is slow and inefficient . Incorrect (Using Loops)\nimport numpy as np arr = np.array([1, 2, 3, 4, 5])\nresult = []\n\nfor i in arr:\nresult.append(i * 2) # Loop -based multiplication\nprint(result)\nCorrect (Vectorized Operations)\nresult = arr * 2 # Fast and efficient\nprint(result)\nWhy? NumPy performs operations in op timized C code , which is significantly faster than Python loops.\n\nBe Careful with Data Types ( dtype ) The Problem: Implicit Type Conversion\nNumPy assigns a data type ( dtype ) automatically , but sometimes this can cause issues.\n\nIncorrect (Mismatched Types)\narr = np.array([1, 2, 3.5, 4]) # Mixed integer & float\nprint(arr.dtype) # float64 (unexpected if you wanted integers)\nCorrect (Explicitly Defining dtype ) arr = np.array([1, 2, 3, 4], dtype=np.int32) # Force integers\nprint(arr.dtype) # int32\nWhy? Specifying dtype ensures consistency and avoids unintended float or integer conversions.\n\nBe Cautious with Floating Point Precision\nThe Problem: Precision Errors in Floating -Point Arithmetic\nFloating -point numbers can introduce rounding errors .\n\nIncorrect (Expecting Exact Equality)\na = np.array([0.1, 0.2, 0.3])\nprint(np.sum(a) == 0.6) # False (precision issue)\nCorrect (Using np.isclose ) print(np.isclose(np.sum(a), 0.6)) # True\nWhy? Floating -point arithmetic is not always exact , so use np.isclose () instead of ==.\n\nBe Aware of Broadcasting Limitations\nThe Problem: Incompatible Shapes in Broadcasting\nNumPy broadcasting allows operations between arrays of different shapes, but sometimes it fails.\nIncorrect (Mismatched Shapes)\narr1 = np.array([[1, 2, 3], [4, 5, 6]]) # Shape (2,3)\narr2 = np.array([10, 20]) # Shape (2,)\n\nresult = arr1 + arr2 # ERROR: Shape mismatch\nCorrect (Reshape for Compatibility)\narr2 = arr2[:, np.newaxis] # Convert to shape (2,1)\nresult = arr1 + arr2 # Now it works!\nprint(result)\nWhy? Ensure shapes are compatible for broadcasting to avoid shape mismatch errors.\n\nAvoid Using copy=False Carelessly\nThe Problem: Modifying an Array by Accident\nUsing views instead of copies can lead to unexpected modificat ions .\n\nIncorrect (Unintended Modification)\narr = np.array([1, 2, 3])\nview_arr = arr.view() # Creates a view, not a copy\nview_arr[0] = 99 # Changes original array too!\nprint(arr) # [99 2 3] Correct (Ensure a Copy is Created)\ncopy_arr = arr.copy() # Cre ates an independent copy\ncopy_arr[0] = 99\nprint(arr) # [1 2 3] (Original remains unchanged)\nWhy? If you don’t want changes in one array to affect another, always use copy() .\n\nAvoid Memory Overhead with Large Arrays\nThe Problem: Creating Huge Arrays Can Crash Your System\nNumPy can allocate very large arrays , leading to memory overflow.\n\nIncorrect (Large Memory Allocation)\nhuge_arr = np.zeros((100000, 100000)) # May crash!\nCorrect (Use Memory Efficient Methods)\nhuge_arr = np.zeros((10000, 10000), dtype =np.float32) # Use smaller dtype\nWhy? Optimize memory by using smaller dtype like float32 instead of float64 .\n\nUse Boolean Masking Instead of Loops for Filtering\nThe Problem: Slow Filtering with Loops\nUsing loops for conditional selection is ineffi cient .\n\nIncorrect (Using Loops for Filtering)\narr = np.array([10, 20, 30, 40, 50])\nresult = [x for x in arr if x &gt; 25] # Slow print(result)\nCorrect (Using Boolean Masking)\nresult = arr[arr &gt; 25] # Fast and efficient\nprint(result) # [30 40 50]\nWhy? Boolean masking is much faster than loops .\n\nBe Aware of np.empty() Behavior\nThe Problem: np.empty() Does Not Initialize Values\nUsing np.empty() does not fill the array with zeros.\n\nIncorrect (Expecting Zeros)\narr = np.empty((2, 3))\nprint(arr) # Contai ns random uninitialized values\nCorrect (Use np.zeros() If You Need Zeros)\narr = np.zeros((2, 3)) # Explicitly initialize with zeros\nWhy? np.empty() is for efficiency, not for initializing values.\n\nAvoid Modifying Arrays During Iteration\nThe Problem: Changing an Array While Iterating Causes Issues\nIf you modify an array inside a loop, it may lead to unexpected results .\n\nIncorrect (Modifying While Iterating)\narr = np.array([1, 2, 3, 4])\nfor i in arr:\ni *= 2 # Does not modify the original array\nprint(arr) # [1 2 3 4] (No change)\nCorrect (Use Vectorized Operations)\narr = arr * 2\nprint(arr) # [2 4 6 8] (Correct result)\nWhy? Direct assignments inside loops do not modify the array in -place.\n\nBe Careful When Using np.append()\nThe Problem: np.append() is Slow for Large Arrays\nAppending elements in NumPy creates a new array every time, making it inefficient.\n\nIncorrect (Repeated np.append() ) arr = np.array([1, 2, 3])\nfor i in range(10000):\narr = np.append(arr, i) # Slow! Correct (Use np.concatenate() or Lists)\narr = np.array([1, 2, 3])\narr = np.concatenate([arr, np.arange(10000)])\nWhy? np.concatenate() is more efficient than multiple np.append() calls.\nSummary: Key Takeaways\n Use vectorized operations instead of loops\n Specify dtype explicitly when needed\n Use np.isclose() instead of == for floating -point comparisons\n Check array shapes when broadcasting\n Use .copy() if you need an independent array\n Optimize memory usage with smaller dtype\n Use Boolean indexing instead of loops\n Understand np.empty() does not initialize values\n Avoid modifying arrays while iterating\n Use np.concatenate() instead of repeated np.append()\nWhere Not to Use NumPy?\nWhile NumPy is a powerful tool for numerical computations, there are cases where using NumPy is not the best choice . Below are scenarios where NumPy should not be used , along with better alternatives.\n\nSmall Data or Simple Lists\nThe Problem: Overhead of NumPy for Small Data\nNumPy is optimized for large numerical computations , but for small lists , the overhead of importing and using NumPy is unnecessary.\nUsing NumPy for Small Lists\nimport numpy as np\narr = np.array([1, 2, 3]) # Unnecessary for small lists\nprint(arr[1]) # Accessing elements\nBetter Alternative: Python Lists\nlst = [1, 2, 3] # Simple and memory efficient\nprint(lst[1])\n\nWhy? Python lists are more efficient for small datasets because NumPy introduces additional overhead .\n\nNon -Numerical Data Processing\nThe Problem: NumPy is Built for Numbers, Not Strings\nNumPy is not desi gned for handling strings, objects, or mixed data types efficiently.\n\nUsing NumPy for Strings\nimport numpy as np\narr = np.array([“apple”, “banana”, “cherry”]) # Strings in NumPy (inefficient)\nprint(arr.dtype) # dtype=‘&lt;U6’\nBetter Alternative: Python Lists or Pandas\nfruits = [“apple”, “banana”, “cherry”] # Use a simple list for strings\nWhy? NumPy arrays are optimized for numerical data , while lists and Pandas handle text better .\n\nDynamic or Growing Arrays\nThe Problem: NumPy Arrays Have Fixed Sizes\nNumPy arrays are static in size, meaning they are inefficient for dynamic resizing . Using NumPy for Dynamic Lists\nimport numpy as np\narr = np.array([1, 2, 3])\narr = np.append(arr, [4, 5, 6]) # Inefficient for large -scale append operations\nBetter Alternat ive: Python Lists\nlst = [1, 2, 3]\nlst.append(4) # Fast and efficient\n\nWhy? Python lists grow dynamically , while NumPy creates a new array every time you append.\n\nDeep Learning & Complex Neural Networks\nThe Problem: NumPy Lacks GPU Support\nFor deep lear ning, NumPy does not utilize GPU acceleration or automatic differentiation.\nUsing NumPy for Deep Learning\nimport numpy as np\narr = np.random.rand(1000, 1000) # Large matrix, but no GPU acceleration\n\nBetter Alternative: Use TensorFlow or PyTorch\nimport torch tensor = torch.rand(1000, 1000).cuda() # Uses GPU acceleration\nWhy? PyTorch and TensorFlow support GPUs and are optimized for deep learning .\n\nHandling Large Datasets That Don’t Fit in Memory\nThe Problem: NumPy Loads Everything into RAM\nNumPy loads entire datasets into memory , which can cause memory overflow for very large datasets.\nUsing NumPy for Large Datasets\nimport numpy as np\nlarge_arr = np.random.rand(100000000) # Consumes a lot of RAM!\nBetter Alternative: Use Pandas, Dask, or Vaex\nimpo rt dask.array as da\nlarge_arr = da.random.random(100000000) # Uses disk -based computation\n\nWhy? Dask and Vaex can handle large datasets by processing them in chunks instead of loading them into memory.\n\nHigh -Performance Computing with Multi -Core Proces sing The Problem: NumPy is Single -Threaded for Most Operations\nWhile NumPy supports multi -threading , many operations run in a single core , making it suboptimal for parallel computing .\n\nUsing NumPy for Parallel Processing\nimport numpy as np\narr = np.arange( 1000000) result = np.sin(arr) # Mostly runs on a single CPU core\nBetter Alternative: Use Numba or Dask\nfrom numba import jit\nimport numpy as np\n@jit(nopython=True)\ndef compute(arr):\nreturn np.sin(arr)\narr = np.arange(1000000)\nresult = compute(arr) # Uses multiple CPU cores\nWhy? Numba and Dask offer better performance for multi -core computing.\n\nImage Processing (Without Specialized Libraries)\nThe Problem: NumPy Lacks Specialized Image Processing Functions\nNumPy can store and manipulate image data , but it does not offer specialized functions like filtering, edge detection, or transformations.\nUsing NumPy for Image Processing\nimport numpy as np\nimage = np.zeros((256, 256, 3)) # Stores image but lacks processing functions\nBetter Alternative: Use Ope nCV or PIL\nimport cv2\nimage = cv2.imread(“image.jpg”) # Reads image efficiently\nimage_gray = cv2.cvtColor(image, cv2.COLOR_BGR2GRAY) # Converts to grayscale\n\nWhy? OpenCV and PIL provide specialized tools for image manipulation.\n8. Handling SQL -Like Data (Tables, Relational Data)\nThe Problem: NumPy Lacks Database Functionality\nNumPy is not designed for working with tabular, structured, or relational data .\nUsing NumPy for DataFrames\nimport numpy as np\ndata = np.array([[” Alice”, 25], [“Bob”, 30], [“Charlie”, 22]])\nBetter Alternative: Use Pandas\nimport pandas as pd\ndata = pd.DataFrame({“Name”: [” Alice”, “Bob”, “Charlie”], ” Age”: [25, 30, 22]})\nprint(data)\nWhy? Pandas provides faster indexing, filtering, and manipulation for tabular data.\n\nObject -Oriented Programming (OOP) & Complex Data Structures\nThe Problem: NumPy Arrays Do Not Support Complex Objects Well\nNumPy only supports homogeneous data types , making it difficult to store complex objects . Using NumPy for Object -Oriented Programming\nimport numpy as np\nclass Person:\ndef init(self, name, age):\nself.name = name\nself.age = age\n\narr = np.array([Person(” Alice”, 25), Person(“Bob”, 30)]) # Works but inefficient\nBetter Alternative: Use Lists or Pandas\npeople = [Person(” Alice” , 25), Person(“Bob”, 30)]\nWhy? Python lists and Pandas DataFrames are better for heterogeneous data ."
  },
  {
    "objectID": "linear_regression.html",
    "href": "linear_regression.html",
    "title": "Linear Regression",
    "section": "",
    "text": "1 Linear Regression\nThis page will contain:\n\nIntuition of linear regression\nEquation and cost function (MSE)\nExample with scikit-learn\nWhen to use / limitations"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Machine Learning Capsule",
    "section": "",
    "text": "This website is my Machine Learning teaching capsule — short, focused notes for: - beginners, - interdisciplinary learners, - and quick revision before interviews or exams.\n\n\n\nStart with Foundations (NumPy and Pandas)\nThen move to Supervised ML (Regression, Classification, SVM, etc.)\nUse the left Table of Contents for quick navigation inside each page\nUse the top menu to jump between topics\n\n\n\n\n\nMachine Learning is a field of AI where computers learn patterns from data and use them to make predictions or decisions, without being explicitly programmed for every rule.\n\n\n\n\nData → collect and clean data\nFeatures → convert raw data into useful numeric form\nModel → choose and train an algorithm\nEvaluation → check accuracy / error using metrics\nDeployment → use the model on new, unseen data\n\n\n\n\n\nSupervised learning: Regression and Classification\n(You can later add)\n\nUnsupervised learning (Clustering, Dimensionality Reduction)\nModel evaluation and regularization\nExplainable AI (SHAP, etc.)\n\n\n\nUse this site along with Jupyter Notebook / VS Code so that you can run all examples yourself."
  },
  {
    "objectID": "index.html#how-to-use-these-notes",
    "href": "index.html#how-to-use-these-notes",
    "title": "Machine Learning Capsule",
    "section": "",
    "text": "Start with Foundations (NumPy and Pandas)\nThen move to Supervised ML (Regression, Classification, SVM, etc.)\nUse the left Table of Contents for quick navigation inside each page\nUse the top menu to jump between topics"
  },
  {
    "objectID": "index.html#what-is-machine-learning",
    "href": "index.html#what-is-machine-learning",
    "title": "Machine Learning Capsule",
    "section": "",
    "text": "Machine Learning is a field of AI where computers learn patterns from data and use them to make predictions or decisions, without being explicitly programmed for every rule.\n\n\n\n\nData → collect and clean data\nFeatures → convert raw data into useful numeric form\nModel → choose and train an algorithm\nEvaluation → check accuracy / error using metrics\nDeployment → use the model on new, unseen data\n\n\n\n\n\nSupervised learning: Regression and Classification\n(You can later add)\n\nUnsupervised learning (Clustering, Dimensionality Reduction)\nModel evaluation and regularization\nExplainable AI (SHAP, etc.)\n\n\n\nUse this site along with Jupyter Notebook / VS Code so that you can run all examples yourself."
  },
  {
    "objectID": "logistic_regression.html",
    "href": "logistic_regression.html",
    "title": "Logistic Regression",
    "section": "",
    "text": "1 Logistic Regression\nThis page will cover:\n\nBinary classification idea\nSigmoid function\nDecision boundary\nExample with scikit-learn"
  },
  {
    "objectID": "pandas_intro.html",
    "href": "pandas_intro.html",
    "title": "Pandas – Data Handling",
    "section": "",
    "text": "1 Pandas – Data Handling\nThis page will contain notes on:\n\nLoading CSV/Excel files\nDataFrames\nHandling missing values\nBasic data exploration for ML"
  }
]